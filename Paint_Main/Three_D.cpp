#include<math.h>
#include<windows.h>
#include<stdio.h>
#include<gl/glut.h>



typedef struct { 
   unsigned short type; 
   unsigned long size; 
   unsigned short reserved1; 
   unsigned short reserved2; 
   unsigned long offsetbits; 
} BITMAPFILEHEADERs; 

typedef struct { 
   unsigned long size; 
   unsigned long width; 
   unsigned long height; 
   unsigned short planes; 
   unsigned short bitcount; 
   unsigned long compression; 
   unsigned long sizeimage; 
   long xpelspermeter; 
   long ypelspermeter; 
   unsigned long colorsused; 
   unsigned long colorsimportant; 
} BITMAPINFOHEADERs; 

typedef struct { 
   unsigned char blue; 
   unsigned char green; 
   unsigned char red; 
} SINGLE_PIXELs;

/*HERE,SPHERE = 2 AND CUBE = 1*/

void Rotate_Obj();
void Initialise();

struct Objects
{
  int obj_type;       /*1 is cube and 2 is sphere*/
  int obj_num;        /*Shows which object*/
  int centre[2];      /*Centre of the object*/
  int boundary[2][2]; /*Shows the boundary of object*/	
  float rot_ang;      /*Shows the angle of orientation*/	
  float pos;	      /*Shows the current position used for trsnslating*/	
  float size;	      /*Shows the size of the object wrt 100x100x100 cube*/  
  int op;	      /*Shows if an operation ahs been performed on the object*/	
};

Objects objs[10];      /*Total 10 3D objects can be drawn*/	

/*Here, these structures contain information about their size,orientation etc.
 *So.each object can be generated by creating the Wire Cube and then changing its
 *position,size etc
 */

int No_Of_Objects,ang;
int first_op = 0;
int Selected_Obj;

void Draw_Cube(int x,int y)
{
	 extern float r,g,b;

	  glMatrixMode(GL_PROJECTION);
	  glLoadIdentity();
	  glOrtho(0 ,800, 0, 600, -500, 500);
	  
	  glMatrixMode (GL_MODELVIEW);		
	  glLoadIdentity();

	 objs[No_Of_Objects].boundary[0][0] = x - 50;
	 objs[No_Of_Objects].boundary[0][1] = y - 50;
	 objs[No_Of_Objects].boundary[1][0] = x + 50;
	 objs[No_Of_Objects].boundary[1][1] = y + 50;
	
	 objs[No_Of_Objects].centre[0]	    = x;
	 objs[No_Of_Objects].centre[1]	    = y;
	 
	 objs[No_Of_Objects].obj_type	    = 1;
	 objs[No_Of_Objects].pos		    = 1;
	 objs[No_Of_Objects].rot_ang	    = 0;
	 objs[No_Of_Objects].size			= 1;
		
	 objs[No_Of_Objects].obj_num	    = No_Of_Objects++;
	  
	  glColor3f(r,g,b);
	  glTranslatef(x, y, 0);	
	  glutWireCube(100);
	  glFlush();		 
 	  	
	 glMatrixMode(GL_MODELVIEW);
	 glLoadIdentity();
	 Draw_Palettes();

	 
}

void Draw_Sphere(int x,int y)
{
	 extern float r,g,b;
	  glMatrixMode(GL_PROJECTION);
	  glLoadIdentity();
	  glOrtho(0 ,800, 0, 600, -500, 500);
	  
	  glMatrixMode (GL_MODELVIEW);		
	  glLoadIdentity();

	 objs[No_Of_Objects].boundary[0][0] = x - 50;
	 objs[No_Of_Objects].boundary[0][1] = y - 50;
	 objs[No_Of_Objects].boundary[1][0] = x + 50;
	 objs[No_Of_Objects].boundary[1][1] = y + 50;
	
	 objs[No_Of_Objects].centre[0]	    = x;
	 objs[No_Of_Objects].centre[1]	    = y;
	 
	 objs[No_Of_Objects].obj_type	    = 2;
	 objs[No_Of_Objects].pos		    = 1;
	 objs[No_Of_Objects].rot_ang	    = 0;
	 objs[No_Of_Objects].size			= 1;
		
	 objs[No_Of_Objects].obj_num	    = No_Of_Objects++;

	  glColor3f(r,g,b);
	  glTranslatef(x, y, 0);	
	  glutWireSphere(50,20,20);
	  glFlush();		 
 	  	
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	Draw_Palettes();

}


void Draw_Cone(int x,int y)
{
	
	  extern float r,g,b;	
	  glMatrixMode(GL_PROJECTION);
	  glLoadIdentity();
	  glOrtho(0 ,800, 0, 600, -500, 500);
	  
	  glMatrixMode (GL_MODELVIEW);		
	  glLoadIdentity();

	 objs[No_Of_Objects].boundary[0][0] = x - 50;
	 objs[No_Of_Objects].boundary[0][1] = y - 50;
	 objs[No_Of_Objects].boundary[1][0] = x + 50;
	 objs[No_Of_Objects].boundary[1][1] = y + 50;
	
	 objs[No_Of_Objects].centre[0]	    = x;
	 objs[No_Of_Objects].centre[1]	    = y;
	 
	 objs[No_Of_Objects].obj_type	    = 3;
	 objs[No_Of_Objects].pos		    = 1;
	 objs[No_Of_Objects].rot_ang	    = 0;
	 objs[No_Of_Objects].size			= 1;
		
	 objs[No_Of_Objects].obj_num	    = No_Of_Objects++;

	  glColor3f(r,g,b);
	  glTranslatef(x, y, 0);	
	  glutWireCone (50, 100, 10, 10);
	  glFlush();		 
 	  	
	 glMatrixMode(GL_MODELVIEW);
	 glLoadIdentity();
	 Draw_Palettes();

	
}

void Draw_Torus(int x,int y)
{
	  extern float r,g,b;	

	  glMatrixMode(GL_PROJECTION);
	  glLoadIdentity();
	  glOrtho(0 ,800, 0, 600, -500, 500);
	  
	  glMatrixMode (GL_MODELVIEW);		
	  glLoadIdentity();

	 objs[No_Of_Objects].boundary[0][0] = x - 50;
	 objs[No_Of_Objects].boundary[0][1] = y - 50;
	 objs[No_Of_Objects].boundary[1][0] = x + 50;
	 objs[No_Of_Objects].boundary[1][1] = y + 50;
	
	 objs[No_Of_Objects].centre[0]	    = x;
	 objs[No_Of_Objects].centre[1]	    = y;
	 
	 objs[No_Of_Objects].obj_type	    = 4;
	 objs[No_Of_Objects].pos		    = 1;
	 objs[No_Of_Objects].rot_ang	    = 0;
	 objs[No_Of_Objects].size			= 1;
		
	 objs[No_Of_Objects].obj_num	    = No_Of_Objects++;
	  
	  glColor3f(r, g, b);
	  glTranslatef(x, y, 0);	
	  glutWireTorus(32, 64, 30, 30);
	  glFlush();		 
 	  	
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	Draw_Palettes();

	
}

void Initialise()
{
	int i;
	for(i=0; i<10; i++){
		objs[i].boundary[0][0] = 0;
		objs[i].boundary[0][1] = 0;
		objs[i].boundary[1][1] = 0;
		objs[i].boundary[1][0] = 0;
	
		objs[i].centre[1]	   = 0;
		objs[i].centre[0]	   = 0;
		objs[i].obj_num		   = 0;
		objs[i].obj_type	   = 0;
		objs[i].pos		       = 0;
		objs[i].rot_ang		   = 0;
		objs[i].size		   = 0;
		objs[i].op		       = 0;

	}
}

void Select_Object(int x,int y)
{
	int i;
	

	for(i = 0;i < No_Of_Objects;i++){
		if( x > objs[i].boundary[0][0] && y > objs[i].boundary[0][1] && x < objs[i].boundary[1][0] && y < objs[i].boundary[1][1])
		{
			  Selected_Obj = i;
				break;
		}

	//Selected_Obj.obj_num = 100;/*In case of no hit*/ 
   }              
}


void Rotate_Obj()
{
	extern int Rot_FlagX , Rot_FlagY , Rot_FlagZ;
	extern float r,g,b; 

	glMatrixMode (GL_MODELVIEW);		
	glLoadIdentity();

	/**************************************************************************/
	/*COde to overwrite the previously drawn object*/
	 glColor3f(1.0,1.0,1.0);
	 glTranslatef(objs[Selected_Obj].centre[0] ,objs[Selected_Obj].centre[1],0);
	 glRotatef(objs[Selected_Obj].rot_ang  , 0,1,1);/*GIORDER!!!!!!!!!!!!!*/
	 glScalef(objs[Selected_Obj].size , objs[Selected_Obj].size , objs[Selected_Obj].size);

	 if(objs[Selected_Obj].obj_type == 1){	
		glColor3f(1.0,1.0,1.0);
		glutWireCube(100);
		glFlush();
	 }
	 else if(objs[Selected_Obj].obj_type == 2){
		glColor3f(1.0,1.0,1.0);
		glutWireSphere(50,20,20);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 3){
		glColor3f(1.0,1.0,1.0);
		glutWireCone (50, 100, 10, 10);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 4){
		glColor3f(1.0,1.0,1.0);
		glutWireTorus(32, 64, 30, 30);
		glFlush();
	}
		
	
	glMatrixMode (GL_MODELVIEW);		
	glLoadIdentity();            /*Load Identity Matrix when job is finished*/
	/*Here, the translations are done in the order of 10 degree rotation and 10%
	scaling.SO do the reverse everytime and with white color*/
	/**************************************************************************/	
	
	objs[Selected_Obj].rot_ang += 10;/*Increase the rot_angle value*/

	/*Rotate and then translate the glutWireCube to get the effect of rotation */
	/*Another cube is actually generated*/
	glTranslatef(objs[Selected_Obj].centre[0] ,objs[Selected_Obj].centre[1],0);
	glScalef(objs[Selected_Obj].size , objs[Selected_Obj].size , objs[Selected_Obj].size);
	glRotatef(objs[Selected_Obj].rot_ang , 0,1,1);/*GIORDER!!!!!!!!!!!!!*/
		
	if(objs[Selected_Obj].obj_type == 1){	
		glColor3f(r,g,b);
		glutWireCube(100);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 2){
		glColor3f(r,g,b);
		glutWireSphere(50,20,20);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 3){
		glColor3f(r,g,b);
		glutWireCone (50, 100, 10, 10);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 4){
		glColor3f(r,g,b);
		glutWireTorus(32, 64, 30, 30);
		glFlush();
	}
	
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	Draw_Palettes();

	

	
}

void Scale_Obj()
{
	extern float r,g,b;	
	extern int Increase_Flag;

	glMatrixMode (GL_MODELVIEW);		
	glLoadIdentity();
	
	/**************************************************************************/
	/*COde to overwrite the previously drawn object*/
	 glColor3f(1.0,1.0,1.0);
	 glTranslatef(objs[Selected_Obj].centre[0] ,objs[Selected_Obj].centre[1],0);
	 glRotatef(objs[Selected_Obj].rot_ang , 0 , 1 , 1);
	 glScalef(objs[Selected_Obj].size , objs[Selected_Obj].size  , objs[Selected_Obj].size);

	 if(objs[Selected_Obj].obj_type == 1){	
		glColor3f(1, 1, 1);
		glutWireCube(100);
		glFlush();
	 }
	 else if(objs[Selected_Obj].obj_type == 2){
		glColor3f(1, 1, 1);
		glutWireSphere(50,20,20);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 3){
		glColor3f(1, 1, 1);
		glutWireCone (50, 100, 10, 10);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 4){
		glColor3f(1, 1, 1);
		glutWireTorus(32, 64, 30, 30);
		glFlush();
	}

	glMatrixMode (GL_MODELVIEW);		
	glLoadIdentity();            /*Load Identity Matrix when job is finished*/
	
	/*Here, the translations are done in the order of 10 degree rotation and 10%
	scaling.SO do the reverse everytime and with white color*/
	
	/**************************************************************************/	


	if(Increase_Flag == 1)
		objs[Selected_Obj].size += 0.1;	/*Increase the size of object by some factor (0.1 here)*/
	
	else 
		objs[Selected_Obj].size -= 0.1;

	/*Scale and then translate the glutWireCube to get the effect of rotation */
	/*Another cube is actually generated*/
	glTranslatef(objs[Selected_Obj].centre[0] ,objs[Selected_Obj].centre[1],0);
	glRotatef(objs[Selected_Obj].rot_ang , 0 , 1 , 1);
	glScalef(objs[Selected_Obj].size  , objs[Selected_Obj].size  , objs[Selected_Obj].size );


	if(objs[Selected_Obj].obj_type == 1){	
		glColor3f(r, g, b);
		glutWireCube(100);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 2){
		glColor3f(r, g, b);
		glutWireSphere(50,20,20);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 3){
		glColor3f(r, g, b);
		glutWireCone (50, 100, 10, 10);
		glFlush();
	}
	else if(objs[Selected_Obj].obj_type == 4){
		glColor3f(r, g, b);
		glutWireTorus(32, 64, 30, 30);
		glFlush();
	}

	if(Increase_Flag == 1){
		objs[Selected_Obj].boundary[0][1] += 5; 
		objs[Selected_Obj].boundary[0][1] += 5; 
		objs[Selected_Obj].boundary[1][0] += 5; 
		objs[Selected_Obj].boundary[1][1] += 5; 
	}else{
		objs[Selected_Obj].boundary[0][1] -= 5; 
		objs[Selected_Obj].boundary[0][1] -= 5; 
		objs[Selected_Obj].boundary[1][0] -= 5; 
		objs[Selected_Obj].boundary[1][1] -= 5; 
	}

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	Draw_Palettes();

	
}


void Rotate_Scene(int x,int y)
{
	float Xnew = x, Ynew = y, phi ,theta , z;
	extern int View;

	glClearColor(0.0,0.0,0.0,0.0);
	glClear (GL_COLOR_BUFFER_BIT);
	

	Xnew = ( x / 800.0 ) * 360.0;
	Ynew = ( y / 600.0 ) * 360.0;

	theta = (Xnew * 3.14 / 180.0);
	phi   = (Ynew * 3.14 / 180.0);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity (); 
	glFrustum(-100.0 , 100 , -100.0 ,100.0 , 100 ,500.0);

	Xnew = 300 * cos(theta) * cos(phi);
	Ynew = 300 * sin(phi);
	z    = 300 * sin(theta) * cos(phi);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity (); 
	gluLookAt (Xnew , Ynew , z + View,0.0 , 0.0 ,0.0, 0.0, 1.0, 0.0);

	glColor3f(1.0, 0.0 ,0.0);
	glutWireCube (150);


	glColor3f(1.0, 1.0 ,1.0);
	glutWireSphere(50, 20 , 20);
	
	glFlush ();

}	

